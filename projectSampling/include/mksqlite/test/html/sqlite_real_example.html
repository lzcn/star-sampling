
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>sqlite_real_example</title><meta name="generator" content="MATLAB 7.13"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2016-04-18"><meta name="DC.source" content="sqlite_real_example.m"><style type="text/css">

body {
  background-color: white;
  margin:10px;
}

h1 {
  color: #990000; 
  font-size: x-large;
}

h2 {
  color: #990000;
  font-size: medium;
}

/* Make the text shrink to fit narrow windows, but not stretch too far in 
wide windows. */ 
p,h1,h2,div.content div {
  max-width: 600px;
  /* Hack for IE6 */
  width: auto !important; width: 600px;
}

pre.codeinput {
  background: #EEEEEE;
  padding: 10px;
}
@media print {
  pre.codeinput {word-wrap:break-word; width:100%;}
} 

span.keyword {color: #0000FF}
span.comment {color: #228B22}
span.string {color: #A020F0}
span.untermstring {color: #B20000}
span.syscmd {color: #B28C00}

pre.codeoutput {
  color: #666666;
  padding: 10px;
}

pre.error {
  color: red;
}

p.footer {
  text-align: right;
  font-size: xx-small;
  font-weight: lighter;
  font-style: italic;
  color: gray;
}

  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#3">Reading content of the logging file in one cell array</a></li><li><a href="#4">Create default SQL table, feeded by cell array</a></li><li><a href="#5">Identifying optional parameters and table update</a></li><li><a href="#6">Query some statistics</a></li><li><a href="#7">Close database</a></li></ul></div><pre class="codeinput"><span class="keyword">function</span> sqlite_real_example
</pre><pre class="codeinput"><span class="comment">%{
</span><span class="comment">      % The logfile has folowing columns:
</span><span class="comment">      1:  Code
</span><span class="comment">      2:  Timestamp
</span><span class="comment">      3:  Mileage at start (km)
</span><span class="comment">      4:  Speed at start (km/h)
</span><span class="comment">      5:  Engine speed at start (rpm)
</span><span class="comment">      6:  Torque at start (Nm)
</span><span class="comment">      7:  Duration (in tenths of a second)
</span><span class="comment">      8:  Distance (m)
</span><span class="comment">      9:  Speed at end (km/h)
</span><span class="comment">      10: Engine speed at end
</span><span class="comment">      11: Torque at end
</span><span class="comment">
</span><span class="comment">      % Column count varies from 11 to 15, so optional columns 12 to 15
</span><span class="comment">      % are condensed to one column, which will be parsed later.
</span><span class="comment">
</span><span class="comment">      % Optional additional columns depending on "Code":
</span><span class="comment">      A:  Optional parameter 1
</span><span class="comment">      B:  Optional parameter 2
</span><span class="comment">      C:  Optional parameter 3
</span><span class="comment">      D:  Optional parameter 4
</span><span class="comment">%}</span>
</pre><h2>Reading content of the logging file in one cell array<a name="3"></a></h2><pre class="codeinput">    clear <span class="string">all</span>, close <span class="string">all</span>, clc

    fid = fopen ( <span class="string">'logfile.asc'</span>, <span class="string">'r'</span> );
    assert( fid &gt; 0 );
    <span class="comment">%                          1  2  3  4  5  6  7  8  9  10 11 (ABCD)</span>
    content = textscan( fid, <span class="string">'%s %s %s %s %s %s %s %s %s %s %s %[^\r\n]'</span>, <span class="keyword">...</span>
                             <span class="string">'CollectOutput'</span>, 1 );
    content = content{1};
    colcnt  = size( content, 2 );
    fclose( fid );
</pre><pre class="codeoutput">Warning: mksqlite: Die noch geoeffneten Datenbanken wurden geschlossen 
</pre><h2>Create default SQL table, feeded by cell array<a name="4"></a></h2><pre class="codeinput">    sql( <span class="string">'open'</span>, <span class="string">''</span> );

    <span class="comment">% Create table with 11 standard columns and one optional column holding the remainder</span>
    sql( [ <span class="string">'CREATE TABLE mantab ('</span> , <span class="keyword">...</span>
           <span class="string">'  Code, '</span>              , <span class="keyword">...</span>
           <span class="string">'  Timestamp, '</span>         , <span class="keyword">...</span>
           <span class="string">'  MileageStart  REAL, '</span>, <span class="keyword">...</span>
           <span class="string">'  SpeedStart    REAL, '</span>, <span class="keyword">...</span>
           <span class="string">'  EngSpeedStart REAL, '</span>, <span class="keyword">...</span>
           <span class="string">'  TorqueStart   REAL, '</span>, <span class="keyword">...</span>
           <span class="string">'  Duration      REAL, '</span>, <span class="keyword">...</span>
           <span class="string">'  Distance      REAL, '</span>, <span class="keyword">...</span>
           <span class="string">'  SpeedEnd      REAL, '</span>, <span class="keyword">...</span>
           <span class="string">'  EngSpeedEnd   REAL, '</span>, <span class="keyword">...</span>
           <span class="string">'  TorqueEnd     REAL, '</span>, <span class="keyword">...</span>
           <span class="string">'  Optional      TEXT )'</span> ] );

    sql( <span class="string">'param_wrapping'</span>, 1 );  <span class="comment">% allow implicit subsequent SQL queries</span>

    <span class="comment">% Pull entire data with a charming "three-liner"</span>
  <span class="comment">% All subsequent queries in one transaction for speed (noticeable when using</span>
  <span class="comment">% an on-disc database)</span>
    sql( <span class="string">'begin'</span> );
    sql( <span class="string">'INSERT INTO mantab VALUES (?%s)'</span>, repmat( <span class="string">',?'</span>, 1, colcnt-1 ), content' );
    sql( <span class="string">'commit'</span> );
</pre><pre class="codeoutput">mksqlite Version 2.2 build: 109, ein MATLAB Interface zu SQLite
(c) 2008-2016 by Martin Kortmann &lt;mail@kortmann.de&gt;
                 Andreas Martin  &lt;andimartin@users.sourceforge.net&gt;
basierend auf SQLite Version 3.10.2 - http://www.sqlite.org
mksqlite verwendet darueber hinaus:
 - DEELX perl kompatible regex engine Version 1.3 (Sswater@gmail.com)
 - BLOSC/LZ4 1.3.0-rc3.dev zur Datenkompression (Francesc Alted / Yann Collett) 
 - MD5 Message-Digest Algorithm (RFC 1321) Implementierung von Alexander Peslyak
   
Platform: PCWIN64, little endian

</pre><h2>Identifying optional parameters and table update<a name="5"></a></h2><p>Codes B, P and V carrying acceleration values in optional columns (A,B). Adding new column and translate parameter A and B as acceleration. Code O carries acceleration value in optional column A.</p><pre class="codeinput">    optional =  { <span class="keyword">...</span>
                    { <span class="string">'"B","P","V"'</span>, <span class="string">'BPV_AccMean'</span>,    <span class="string">'BPV_AccRng'</span> },
                    { <span class="string">'"O"'</span>,         <span class="string">'O_LongAdj'</span> },
                };

    <span class="comment">% Creating new data column(s) and extract conditional parameters into them</span>
    <span class="keyword">for</span> i = 1:numel( optional )           <span class="comment">% rows of cell array 'optional'</span>
        code = optional{i}{1};
        <span class="comment">% Build regex pattern for one line entry.</span>
        re = cell( 2, numel( optional{i} ) - 1 );
        re(1,:)     = {<span class="string">'([^\t*]*)'</span>};       <span class="comment">% column data, chars not containing tabs</span>
        re(2,:)     = {<span class="string">'\t'</span>};              <span class="comment">% column separator</span>
        re(end,end) = {<span class="string">''</span>};                <span class="comment">% last column has no tab</span>
        re          = [<span class="string">'^'</span>, re{:}, <span class="string">'$'</span>];   <span class="comment">% fence with 'begin' and 'end' constraints</span>
        <span class="keyword">for</span> j = 2:numel( optional{i} )    <span class="comment">% iterate used optional columns</span>
            <span class="comment">% Create columns and update</span>
            colname = optional{i}{j};
            sql( <span class="string">'ALTER TABLE mantab ADD COLUMN %s REAL'</span>, colname );
            sql( <span class="string">'UPDATE mantab SET %s = REGEX( Optional, "%s", "$%d" ) WHERE Code IN (%s)'</span>, <span class="keyword">...</span>
                 colname, re, j-1, code );
        <span class="keyword">end</span>
    <span class="keyword">end</span>
</pre><h2>Query some statistics<a name="6"></a></h2><pre class="codeinput">    sql( <span class="string">'result_type'</span>, 1 );  <span class="comment">% Set result type to "struct of arrays"</span>
    [result, count, names] = sql( <span class="string">'SELECT * FROM mantab WHERE Code="B" AND BPV_AccMean&gt;30 ORDER BY BPV_AccRng'</span> );

    plot( result.BPV_AccRng / 100, <span class="string">'k-'</span>, <span class="string">'linewidth'</span>, 3 )
    title( <span class="string">'Acceleration range with means &gt; 0.3g'</span>, <span class="string">'fontsize'</span>, 12 );
    xlabel( <span class="string">'Nr.'</span> );
    ylabel( <span class="string">'Acceleration [g]'</span> );
    grid

    <span class="comment">% Omit percental fractions of codes</span>
    sql( <span class="string">'result_type'</span>, 2 );  <span class="comment">% Set result type to "cell matrix"</span>
    result = sql( [<span class="string">'SELECT Code, '</span>, <span class="keyword">...</span>
                   <span class="string">'ROUND(SUM(Distance)/(SELECT SUM(Distance) FROM mantab)*100,1) as Percentage '</span>, <span class="keyword">...</span>
                   <span class="string">'FROM mantab '</span>, <span class="keyword">...</span>
                   <span class="string">'WHERE Distance NOT NULL '</span>, <span class="keyword">...</span>
                   <span class="string">'GROUP BY 1 ORDER BY 1'</span>] )
</pre><pre class="codeoutput">
result = 

    'A'    [                 0]
    'B'    [ 9.199999999999999]
    'H'    [ 1.400000000000000]
    'K'    [ 2.300000000000000]
    'L'    [23.600000000000001]
    'O'    [                 0]
    'P'    [ 0.100000000000000]
    'S'    [                 0]
    'U'    [60.299999999999997]
    'V'    [ 3.100000000000000]
    'Z'    [                 0]

</pre><img vspace="5" hspace="5" src="sqlite_real_example_01.jpg" alt=""> <h2>Close database<a name="7"></a></h2><pre class="codeinput">    sql( <span class="string">'close'</span> );
</pre><p class="footer"><br>
      Published with MATLAB&reg; 7.13<br></p></div><!--
##### SOURCE BEGIN #####
function sqlite_real_example

%{
      % The logfile has folowing columns:
      1:  Code
      2:  Timestamp
      3:  Mileage at start (km)
      4:  Speed at start (km/h)
      5:  Engine speed at start (rpm)
      6:  Torque at start (Nm)
      7:  Duration (in tenths of a second)
      8:  Distance (m)
      9:  Speed at end (km/h)
      10: Engine speed at end
      11: Torque at end

      % Column count varies from 11 to 15, so optional columns 12 to 15
      % are condensed to one column, which will be parsed later.

      % Optional additional columns depending on "Code":
      A:  Optional parameter 1
      B:  Optional parameter 2
      C:  Optional parameter 3
      D:  Optional parameter 4
%}

    %% Reading content of the logging file in one cell array
    clear all, close all, clc

    fid = fopen ( 'logfile.asc', 'r' );
    assert( fid > 0 );
    %                          1  2  3  4  5  6  7  8  9  10 11 (ABCD)
    content = textscan( fid, '%s %s %s %s %s %s %s %s %s %s %s %[^\r\n]', ...
                             'CollectOutput', 1 );
    content = content{1};
    colcnt  = size( content, 2 );
    fclose( fid );

    %% Create default SQL table, feeded by cell array
    sql( 'open', '' );

    % Create table with 11 standard columns and one optional column holding the remainder
    sql( [ 'CREATE TABLE mantab (' , ...
           '  Code, '              , ...
           '  Timestamp, '         , ...
           '  MileageStart  REAL, ', ...
           '  SpeedStart    REAL, ', ...
           '  EngSpeedStart REAL, ', ...
           '  TorqueStart   REAL, ', ...
           '  Duration      REAL, ', ...
           '  Distance      REAL, ', ...
           '  SpeedEnd      REAL, ', ...
           '  EngSpeedEnd   REAL, ', ...
           '  TorqueEnd     REAL, ', ...
           '  Optional      TEXT )' ] );

    sql( 'param_wrapping', 1 );  % allow implicit subsequent SQL queries

    % Pull entire data with a charming "three-liner"
  % All subsequent queries in one transaction for speed (noticeable when using
  % an on-disc database)
    sql( 'begin' );
    sql( 'INSERT INTO mantab VALUES (?%s)', repmat( ',?', 1, colcnt-1 ), content' );
    sql( 'commit' );

    %% Identifying optional parameters and table update
    % Codes B, P and V carrying acceleration values in optional columns
    % (A,B). Adding new column and translate parameter A and B as
    % acceleration.
    % Code O carries acceleration value in optional column A.

    optional =  { ...
                    { '"B","P","V"', 'BPV_AccMean',    'BPV_AccRng' },
                    { '"O"',         'O_LongAdj' },
                };

    % Creating new data column(s) and extract conditional parameters into them
    for i = 1:numel( optional )           % rows of cell array 'optional'
        code = optional{i}{1};
        % Build regex pattern for one line entry.
        re = cell( 2, numel( optional{i} ) - 1 );
        re(1,:)     = {'([^\t*]*)'};       % column data, chars not containing tabs
        re(2,:)     = {'\t'};              % column separator
        re(end,end) = {''};                % last column has no tab
        re          = ['^', re{:}, '$'];   % fence with 'begin' and 'end' constraints
        for j = 2:numel( optional{i} )    % iterate used optional columns
            % Create columns and update
            colname = optional{i}{j};
            sql( 'ALTER TABLE mantab ADD COLUMN %s REAL', colname );
            sql( 'UPDATE mantab SET %s = REGEX( Optional, "%s", "$%d" ) WHERE Code IN (%s)', ...
                 colname, re, j-1, code );
        end
    end


    %% Query some statistics
    sql( 'result_type', 1 );  % Set result type to "struct of arrays"
    [result, count, names] = sql( 'SELECT * FROM mantab WHERE Code="B" AND BPV_AccMean>30 ORDER BY BPV_AccRng' );

    plot( result.BPV_AccRng / 100, 'k-', 'linewidth', 3 )
    title( 'Acceleration range with means > 0.3g', 'fontsize', 12 );
    xlabel( 'Nr.' );
    ylabel( 'Acceleration [g]' );
    grid

    % Omit percental fractions of codes
    sql( 'result_type', 2 );  % Set result type to "cell matrix"
    result = sql( ['SELECT Code, ', ...
                   'ROUND(SUM(Distance)/(SELECT SUM(Distance) FROM mantab)*100,1) as Percentage ', ...
                   'FROM mantab ', ...
                   'WHERE Distance NOT NULL ', ...
                   'GROUP BY 1 ORDER BY 1'] )

  %% Close database
    sql( 'close' );

##### SOURCE END #####
--></body></html>